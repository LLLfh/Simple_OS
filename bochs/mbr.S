;主引导程序
;------------------------------------------
SECTION MBR vstart=0x7c00   ; 向编译器表示咱们这儿起始地址应为0x7c00
  mov ax,cs
  mov dx,ax                 ; 由于BIOS通过 0:0x7c00跳转MBR，所以此时cs为0,因此借他来初始化寄存器
  mov es,ax
  mov ss,ax
  mov fs,ax
  mov sp,0x7c00
; 清屏利用0x06号子功能，上卷全部行即可清屏
;-------------------------------------------
;INT 0x10    功能号：0x06    功能：上卷窗口
;-------------------------------------------
;输入：
;AH 功能号:0x06
;AL = 上卷行数（若为0则表示全部行，太适合我们辣）
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值
  mov ax,0x600
  mov bx,0x700
  mov cx,0          ; 左上角(0,0)
  mov dx,0x184f     ; 右下角(0x4f,0x18),在VGA文本模式中一行只能容纳80字符
  int 0x10

;;;;;;;; 下面三行获取光标位置 ;;;;;;;;;;;;;;;
; ,get_cursor获取光标位置，并在光标位置打印字符
  mov ah,3          ;输入： 3号子功能即为获取当前光标位置
  mov bh,0          ;bh 寄存器存储的是待获取光标的页号

  int 0x10          ;输出 ch=光标开始行，cl =光标结束行
                    ;dh=光标所在行号，dl=光标所在页号
;;;;;;;; 获取光标结束 ;;;;;;;;;;;;;;

;;;;;;;;;;; 打印字符串 ;;;;;;;;;;;;;;;;
;依旧用中断的0x13号子功能
  mov ax, message       ;文件末会声明此字符串
  mov bp, ax            ;es:bp为串首地址，es此时由于最开始的初始化，同cs一致
;光标位置需要用到dx寄存器内容，cx中的光标位置可忽略
  mov cx,0xa              ;cx 为串长度，不包括结束副\x00
  mov ax,0x1301         ;ah=13为显示字符功能号
                        ;al = 01 表示该功能的模式，具体模式有以下几种
                        ;(1)0,显示字符串，光标返回起始位置
                        ;(2)1,显示字符串，光标跟随到新位置
                        ;(3)2,显示字符串以及属性，光标返回起始位置
                        ;(4)3,显示字符串以及属性，光标跟随到新位置
  mov bx,0x2            ;bh存储要显示的页号，此时为0页，bl中是字符属性，bl=02h表示黑底绿字
  int 0x10              ; 执行BIOS 0x10中断
;;;;;;;;;; 打印字符串结束 ;;;;;;;;;;;;;;;
  jmp $                 ;悬停指针

  message  db "Hello lfh"
  times 510-($-$$) db 0     ;$-$$表示该指令行距离section起始地址的偏移，这里也可表示为目前指令大小
  db 0x55,0xaa


